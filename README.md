# Lab3_DiscreteMaths

Лабораторна робота 3: Дискретна математика

## Детальний опис `regex.py`

Файл `regex.py` реалізує скінченний автомат (Finite State Machine, FSM) для перевірки відповідності рядків регулярним виразам. Нижче наведено детальний опис роботи коду.

---

### Принцип роботи скінченного автомата та його реалізація в коді

#### 1. Що таке скінченний автомат?
Скінченний автомат — це математична модель, що складається зі станів та переходів між ними. У контексті регулярних виразів, кожен стан представляє певну частину шаблону, а переходи відбуваються при збігу символів вхідного рядка з очікуваннями стану. Автомат починає роботу в початковому стані та рухається по станах, "споживаючи" символи рядка. Якщо автомат досягає кінцевого (термінального) стану після обробки всього рядка, рядок вважається таким, що відповідає регулярному виразу.

#### 2. Як регулярний вираз перетворюється на автомат (компіляція)
Процес перетворення регулярного виразу на скінченний автомат називається компіляцією. У нашому коді це відбувається в конструкторі класу `RegexFSM` (`__init__`):

1.  **Ініціалізація**: Створюється початковий стан `StartState`.
2.  **Розбір виразу**: Регулярний вираз читається символ за символом.
    *   Для звичайних символів (наприклад, 'a', '1') створюється `AsciiState`.
    *   Для спеціального символу `.` (будь-який символ) створюється `DotState`.
    *   Для класів символів (наприклад, `[a-z0-9]`) створюється `CharacterClassState`, який аналізує специфікацію класу (діапазони, окремі символи, заперечення `^`).
    *   Оператори `*` (нуль або більше повторень) та `+` (одне або більше повторень) не створюють нових станів для символів, а модифікують *попередній* стан. Вони "обгортають" попередній стан у `StarState` або `PlusState` відповідно. Ці стани-обгортки дозволяють попередньому стану або повторюватися, або бути пропущеним (у випадку `*`).
3.  **Зв'язування станів**: Кожен новостворений стан додається до списку `next_states` попереднього стану, формуючи ланцюжок. Для `StarState` та `PlusState` додається також перехід на самих себе, щоб забезпечити повторення.
4.  **Завершення**: До `next_states` останнього стану в ланцюжку додається `TerminationState`. Якщо регулярний вираз порожній або складається лише з оператора, який не може існувати без попереднього символу (наприклад, сам по собі `*`), виникає помилка.

#### 3. Як автомат перевіряє рядок
Перевірка відповідності рядка відбувається в методі `check_string(input_str)`:

1.  **Початковий набір станів**: Перевірка починається з набору, що містить лише `self.start_state`. Цей набір одразу розширюється за допомогою епсилон-переходів (див. нижче).
2.  **Обробка символів**: Для кожного символу `char` вхідного рядка `input_str`:
    *   Формується новий порожній набір `next_possible_states`.
    *   Для кожного `state` з поточного активного набору станів перебираються всі `next_state` в його `state.next_states`.
    *   Якщо `next_state.check_self(char)` повертає `True` (тобто наступний стан може "прийняти" поточний символ), цей `next_state` додається до `next_possible_states`.
    *   Якщо після обробки всіх поточних активних станів набір `next_possible_states` залишається порожнім, це означає, що поточний символ `char` не може бути прийнятий. Рядок не відповідає шаблону, повертається `False`.
    *   Поточний набір активних станів оновлюється на `next_possible_states` і знову розширюється за допомогою епсилон-переходів.
3.  **Завершення перевірки**: Після обробки всіх символів рядка, викликається метод `_can_terminate_without_input(current_states)`. Він перевіряє, чи можна з будь-якого з поточних активних станів досягти `TerminationState`, використовуючи лише епсилон-переходи. Якщо так, рядок відповідає шаблону (`True`), інакше — ні (`False`).
    *   Окремо обробляється випадок порожнього вхідного рядка: для нього одразу викликається `_can_terminate_without_input` на початковому наборі станів.

---

### Реалізація класів станів

Кожен тип елемента регулярного виразу представлений окремим класом стану, що успадковується від абстрактного класу `State`.

#### Базовий клас `State`
Абстрактний клас, що визначає інтерфейс для всіх станів.
```python
class State(ABC):
    """Abstract base class for all states in the finite state machine.
    States represent different parts of a regex pattern and define how to match characters."""
    @abstractmethod
    def __init__(self) -> None:
        pass

    @abstractmethod
    def check_self(self, char: str) -> bool:
        pass

    def check_next(self, next_char: str) -> State | Exception:
        for state in self.next_states:
            if state.check_self(next_char):
                return state
        raise NotImplementedError("rejected string")
```

#### `StartState`
Початковий стан, сам по собі не відповідає жодному символу.
```python
class StartState(State):
    """Initial state of the FSM that doesn't match any character itself."""
    def __init__(self):
        self.next_states = []

    def check_self(self, char):
        return False
```

#### `TerminationState`
Кінцевий стан, що позначає успішне завершення розбору.
```python
class TerminationState(State):
    """Final state of the FSM indicating successful pattern match."""
    def __init__(self) -> None:
        self.next_states = []

    def check_self(self, char: str) -> bool:
        return False
```

#### `AsciiState`
Відповідає конкретному символу.
```python
class AsciiState(State):
    """State that matches a specific character like 'a' or '1'."""
    def __init__(self, symbol: str) -> None:
        self.next_states = []
        self.curr_sym = symbol

    def check_self(self, curr_char: str) -> bool:
        return self.curr_sym == curr_char
```

#### `DotState`
Відповідає будь-якому одному символу (оператор `.`).
```python
class DotState(State):
    """State for the dot operator (.) that matches any single character."""
    def __init__(self):
        self.next_states = []

    def check_self(self, char: str):
        return True
```

#### `CharacterClassState`
Відповідає символу з певного набору або діапазону (наприклад, `[a-zA-Z0-9]`, `[^0-9]`).
```python
class CharacterClassState(State):
    """State for character classes like [a-z0-9] that match any character in the specified set."""
    def __init__(self, class_spec: str):
                self.next_states = []
        self.char_ranges = []
        self.individual_chars = set()
        self.negated = False

        if class_spec and class_spec[0] == '^':
            self.negated = True
            class_spec = class_spec[1:]

        i = 0
        while i < len(class_spec):
            if i + 2 < len(class_spec) and class_spec[i+1] == '-':
                self.char_ranges.append((class_spec[i], class_spec[i+2]))
                i += 3
            else:
                self.individual_chars.add(class_spec[i])
                i += 1
    def check_self(self, char: str) -> bool:
        in_class = any(ord(start) <= ord(char) <= ord(end) for\
                       start, end in self.char_ranges)
        if not in_class:
            in_class = char in self.individual_chars

        return not in_class if self.negated else in_class
```

#### `StarState` та `PlusState`
Реалізують оператори `*` (нуль або більше) та `+` (один або більше) відповідно. Вони "обгортають" попередній стан (`checking_state`) і делегують йому перевірку символу.
```python
class StarState(State):
    def __init__(self, checking_state: State):
# ...existing code...
        self.checking_state = checking_state

    def check_self(self, char):
        return self.checking_state.check_self(char)

class PlusState(State):
    def __init__(self, checking_state: State):
# ...existing code...
        self.checking_state = checking_state

    def check_self(self, char):
        return self.checking_state.check_self(char)
```
У конструкторі `RegexFSM` ці стани додають самі себе до своїх `next_states`, щоб забезпечити можливість повторення. `StarState` також дозволяє "пропустити" `checking_state`, що реалізується через епсилон-переходи.

#### Епсилон-переходи
Епсилон-переходи — це переходи між станами, які відбуваються *без споживання* символу з вхідного рядка. Вони критично важливі для коректної роботи операторів типу `*` (який дозволяє нульову кількість повторень) та для загальної гнучкості автомата.

У коді вони реалізовані двома допоміжними методами класу `RegexFSM`:

1.  `_add_epsilon_transitions(states)`:
    *   Приймає набір поточних активних станів.
    *   Рекурсивно (або ітеративно з використанням робочого списку) додає до цього набору всі стани, досяжні з поточних через епсилон-переходи.
    *   Особливу увагу приділяє `StarState`: якщо `StarState` є серед активних, то до активних додаються також його "звичайні" наступні стани (ті, що йдуть *після* `StarState` у регулярному виразі), оскільки `StarState` може бути "пропущений" (нуль повторень). Також, якщо `StarState` вказує сам на себе (для повторень), цей зв'язок також враховується як епсилон-перехід.

2.  `_can_terminate_without_input(states)`:
    *   Використовується наприкінці перевірки рядка (або для порожнього рядка).
    *   Перевіряє, чи можна з будь-якого стану в наданому наборі `states` досягти `TerminationState`, рухаючись лише через епсилон-переходи (тобто, не споживаючи більше символів).
    *   Це важливо, наприклад, якщо регулярний вираз закінчується на `a*`, і рядок закінчився після `a`. Автомат має визнати це як успішний збіг.

Ці два методи гарантують, що автомат правильно враховує всі можливі шляхи, включаючи ті, де деякі частини шаблону (як `*`) можуть не збігатися з жодним символом.

---

### Приклад роботи автомата

Розглянемо регулярний вираз: `[a-c]+d`
Це означає: один або більше символів з набору {'a', 'b', 'c'}, за якими обов'язково слідує символ 'd'.

#### 1. Побудова автомата для `[a-c]+d` (спрощена схема)

Автомат буде складатися з таких основних частин:

1.  `S0: StartState` (Початковий стан)
2.  `S1: CharacterClassState` для `[a-c]` (Перевіряє, чи символ є 'a', 'b', або 'c')
3.  `S2: PlusState`, що "обгортає" `S1`. Цей стан відповідає за логіку `+` для `[a-c]`.
4.  `S3: AsciiState` для 'd' (Перевіряє, чи символ є 'd')
5.  `S4: TerminationState` (Кінцевий стан)

**Зв'язки між станами (включаючи логіку `PlusState`):**

*   `S0` -> `S2` (Починаємо з `PlusState` для `[a-c]`)
*   `S2` (внутрішньо використовує `S1` для перевірки символу):
    *   Якщо символ збігається з `[a-c]` (через `S1`):
        *   Можливий перехід назад на `S2` (для наступного символу з `[a-c]`, реалізуючи `+`)
        *   Можливий перехід на `S3` (якщо частина `[a-c]+` завершена і очікується 'd')
*   `S3` -> `S4` (Після успішної перевірки 'd' переходимо до кінцевого стану)

#### 2. Перевірка рядка "abd"

1.  **Початок**: Поточний набір станів `{S0}`.
    `_add_epsilon_transitions({S0})` -> додає `S2` (через неявний епсилон-перехід до першого значущого стану). Поточні активні стани (після епсилонів): `{S0, S2}`.
2.  **Символ 'a'**:
    *   `S2` (через `S1`) приймає 'a'.
    *   Можливі наступні стани: знову `S2` (для наступного символу `[a-c]`) або `S3` (якщо далі буде 'd').
    *   `_add_epsilon_transitions` для цих станів. Поточні активні стани: `{S2, S3}` (спрощено).
3.  **Символ 'b'**:
    *   `S2` (через `S1`) приймає 'b'.
    *   Можливі наступні стани: знову `S2` або `S3`.
    *   `_add_epsilon_transitions`. Поточні активні стани: `{S2, S3}`.
4.  **Символ 'd'**:
    *   З активних станів `{S2, S3}`:
        *   `S2` (через `S1`) *не* приймає 'd'.
        *   `S3` приймає 'd'.
    *   Наступний стан після `S3` - це `S4` (`TerminationState`).
    *   `_add_epsilon_transitions`. Поточні активні стани: `{S4}`.
5.  **Кінець рядка**:
    *   Викликається `_can_terminate_without_input({S4})`.
    *   Оскільки `S4` є `TerminationState`, повертається `True`.
6.  **Результат**: Рядок "abd" відповідає шаблону.

#### 3. Перевірка рядка "d"

1.  **Початок**: Активні стани (після епсилонів): `{S0, S2}`.
2.  **Символ 'd'**:
    *   `S2` (через `S1`) *не* приймає 'd'. `PlusState` вимагає хоча б одного збігу для `checking_state` (`S1`), перш ніж він зможе перейти до наступного стану (`S3`). Оскільки `S1` не прийняв 'd', і це перший символ для `PlusState`, перехід до `S3` неможливий.
    *   Набір наступних можливих станів порожній.
3.  **Результат**: `False`. Рядок "d" не відповідає (немає частини `[a-c]+`).

#### 4. Перевірка рядка "acdx"

1.  **Символи 'a', 'c', 'd'**: Обробляються аналогічно до прикладу "abd", і після 'd' активним станом стає `{S4}`.
2.  **Символ 'x'**:
    *   Поточний активний стан `{S4}` (`TerminationState`).
    *   `S4.check_self('x')` повертає `False`. `S4` не має `next_states`.
    *   Набір наступних можливих станів порожній.
3.  **Результат**: `False`. Рядок "acdx" не відповідає (є зайвий символ 'x' після повного збігу `[a-c]+d`).

Цей приклад ілюструє, як комбінація станів, їхніх методів `check_self` та логіки епсилон-переходів дозволяє автомату коректно обробляти різні аспекти регулярних виразів.

---

### Приклад роботи

```python
# Створення автомата для регулярного виразу "a*b"
fsm = RegexFSM("a*b")

# Перевірка рядків
print(fsm.check_string("b"))      # True
print(fsm.check_string("aaab"))   # True
print(fsm.check_string("c"))      # False
```

Також в репозиторії наявні unittest'и, які перевіряють наскільки правильно працює імплементований код в `regex.py`.
---

Зроблено в межах курсу Дискретної математики 2 Українського католицького університету.