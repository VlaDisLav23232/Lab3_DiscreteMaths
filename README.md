# Lab3_DiscreteMaths

Лабораторна робота 3: Дискретна математика

## Детальний опис `regex.py`

Файл `regex.py` реалізує скінченний автомат (Finite State Machine, FSM) для перевірки відповідності рядків регулярним виразам. Нижче наведено детальний опис роботи коду.

---

### Алгоритм роботи

Уявіть, що регулярний вираз — це інструкція для пошуку певних шаблонів у тексті. Наш код перетворює цю інструкцію на спеціальну машину (скінченний автомат), яка крок за кроком перевіряє текст.

1.  **Розбір Інструкції (Регулярного Виразу)**:
    *   Коли ви даєте програмі регулярний вираз (наприклад, `a*b`), вона починає його "читати" зліва направо.
    *   Кожен символ або група символів у регулярному виразі (як `a`, `*`, `b`, `[0-9]`) перетворюється на окремий "стан" або "вузол" у нашій машині. Кожен такий стан знає, яку частину шаблону він шукає.
        *   Наприклад, якщо в регулярному виразі є `a`, створюється стан, який шукає саме літеру `a`.
        *   Якщо є `.`, створюється стан, який шукає будь-який один символ.
        *   Якщо є `[0-9]`, створюється стан, який шукає будь-яку цифру.
        *   Символи `*` (нуль або більше разів) та `+` (один або більше разів) є особливими. Вони не створюють власний стан для символу, а модифікують попередній стан, дозволяючи йому повторюватися. Наприклад, для `a*` стан, що шукає `a`, отримує можливість "зациклитися" на собі.

2.  **Побудова Машини (Скінченного Автомата)**:
    *   Після того, як усі частини регулярного виразу перетворені на стани, ці стани з'єднуються між собою у певній послідовності, утворюючи ланцюжок. Цей ланцюжок і є нашою машиною.
    *   Машина завжди починає роботу з початкового стану (`StartState`).
    *   У кінці ланцюжка станів додається спеціальний кінцевий стан (`TerminationState`). Якщо машина досягає цього стану після перевірки всього тексту, це означає, що текст відповідає регулярному виразу.

3.  **Перевірка Тексту (Рядка)**:
    *   Тепер машина готова перевіряти текст. Візьмемо, наприклад, регулярний вираз `a*b` і текст `aaab`.
    *   **Крок 1**: Машина перебуває в початковому стані. Перший символ тексту — `a`.
    *   **Крок 2**: Машина переходить до стану, що відповідає `a`. Цей стан "поглинає" першу `a` з тексту. Оскільки після `a` йде `*`, цей стан може повторюватися.
    *   **Крок 3**: Наступний символ тексту — знову `a`. Стан `a*` знову "поглинає" цю `a`.
    *   **Крок 4**: Третій символ тексту — знову `a`. Стан `a*` "поглинає" і цю `a`.
    *   **Крок 5**: Четвертий символ тексту — `b`. Машина намагається перейти від стану `a*` до наступного стану. Наступний стан у нашому регулярному виразі — це `b`. Стан `b` "поглинає" символ `b` з тексту.
    *   **Крок 6**: Текст закінчився. Машина успішно пройшла через усі символи тексту і зараз перебуває у стані `b`. З цього стану є перехід до кінцевого стану (`TerminationState`).
    *   **Результат**: Оскільки машина змогла обробити весь текст і досягти кінцевого стану, текст `aaab` відповідає регулярному виразу `a*b`.

    *   **Що якби текст був `aac`?**
        *   Після обробки `aa` машина очікувала б `b` (або ще `a`, якби `*` продовжувався). Але вона отримує `c`.
        *   Стан `b` не може "поглинути" `c`. Інших шляхів немає. Машина "застрягає".
        *   **Результат**: Текст `aac` не відповідає регулярному виразу `a*b`.

    *   **Обробка `*` (нуль або більше)**:
        *   Якщо регулярний вираз `a*b` і текст `b`:
            *   Машина в початковому стані. Перший символ `b`.
            *   Стан `a*` може бути пропущений (нуль повторень `a`).
            *   Машина одразу переходить до стану `b`, який "поглинає" `b`.
            *   Досягнуто кінцевого стану. Результат: `True`.

    *   **Обробка `+` (один або більше)**:
        *   Якщо регулярний вираз `a+b` і текст `b`:
            *   Машина в початковому стані. Перший символ `b`.
            *   Стан `a+` вимагає хоча б одне `a`. Оскільки його немає, машина "застрягає". Результат: `False`.
        *   Якщо текст `ab`:
            *   Стан `a+` "поглинає" `a`.
            *   Потім стан `b` "поглинає" `b`.
            *   Досягнуто кінцевого стану. Результат: `True`.

Цей процес крок за кроком перевіряє, чи відповідає вхідний текст заданому шаблону, використовуючи логіку переходів між станами, визначену регулярним виразом.

---

### Детальний опис класів

#### 1. `State` (Абстрактний базовий клас)
- Базовий клас для всіх станів.
- **Методи**:
  - `check_self(char: str) -> bool`: Перевіряє, чи приймає стан символ.
  - `check_next(next_char: str) -> State | Exception`: Знаходить наступний стан, який може прийняти символ.

#### 2. `StartState`
- Початковий стан, який не приймає жодного символу.

#### 3. `TerminationState`
- Термінальний стан, який позначає успішне завершення перевірки.

#### 4. `DotState`
- Стан для оператора `.` (приймає будь-який символ).

#### 5. `AsciiState`
- Стан для конкретного символу (наприклад, `a` або `1`).

#### 6. `CharacterClassState`
- Стан для класів символів (наприклад, `[a-z]` або `[^0-9]`).
- Підтримує діапазони символів і заперечення (`^`).

#### 7. `StarState`
- Стан для оператора `*` (нуль або більше повторень попереднього стану).

#### 8. `PlusState`
- Стан для оператора `+` (один або більше повторень попереднього стану).

#### 9. `RegexFSM`
- Основний клас, який компілює регулярний вираз у скінченний автомат і перевіряє рядки.

---

### Приклад роботи

```python
# Створення автомата для регулярного виразу "a*b"
fsm = RegexFSM("a*b")

# Перевірка рядків
print(fsm.check_string("b"))      # True
print(fsm.check_string("aaab"))   # True
print(fsm.check_string("c"))      # False
```

---
